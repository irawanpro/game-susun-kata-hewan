<!DOCTYPE html><html lang="id">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Sambung Line - GlowandGrow</title>
<style>
  :root{color-scheme: dark}
  html,body{height:100%;margin:0;background:#0b1220;color:#e6eef8;overflow:hidden;font-family:system-ui,Segoe UI,Roboto,Arial}
  canvas{display:block;width:100%;height:100%;touch-action:none;background:#071021}
  #instructions,#overlay{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;flex-direction:column;padding:20px;text-align:center;z-index:30}
  #instructions{background:linear-gradient(180deg,rgba(2,6,23,.94),rgba(2,6,23,.96))}
  #overlay{display:none;background:rgba(2,6,23,.9)}
  button{appearance:none;border:0;border-radius:10px;padding:12px 18px;background:#22c55e;color:#071021;font-weight:700;cursor:pointer}
  #hud{position:fixed;left:12px;top:10px;padding:8px 12px;background:rgba(255,255,255,.03);border-radius:10px;z-index:20;font-weight:700}
  .toast{position:fixed;left:50%;bottom:28px;transform:translateX(-50%);background:#0b1220;color:#e6eef8;padding:8px 12px;border-radius:8px;font-size:13px;opacity:0;transition:opacity .2s;z-index:35}
  .toast.show{opacity:1}
</style>
</head>
<body>
  <div id="hud">Level 1 / 20</div>
  <canvas id="game"></canvas>  <div id="instructions">
    <h1 style="margin:0 0 8px 0">Instruksi Permainan</h1>
    <p style="max-width:620px;margin:0 0 12px">Tarik satu garis untuk menghubungkan semua titik dalam satu go. Urutan titik bebas — jangan angkat jari sebelum selesai.</p>
    <small style="opacity:.8">Created by : <b>GlowandGrow</b><br>Contact person : <b>+6289629065679 / Rahma</b></small>
    <div style="height:18px"></div>
    <button id="startBtn">Mulai Game</button>
  </div>  <div id="overlay">
    <h2 id="overlayTitle">Level Selesai!</h2>
    <p id="overlayDesc" style="margin:6px 0 12px 0"></p>
    <div>
      <button id="nextBtn">Lanjut Level Berikutnya</button>
      <button id="restartBtn" style="margin-left:8px;background:#38bdf8">Main dari Level 1</button>
    </div>
  </div>  <div class="toast" id="toast">Belum semua titik tersambung</div><script>
/* Final game file: 20 levels + landscape lock + event-listener fix + transition */
// --- Anti-zoom
window.addEventListener('wheel', e => { if (e.ctrlKey) e.preventDefault(); }, { passive:false });
['gesturestart','gesturechange','gestureend'].forEach(ev=>window.addEventListener(ev, e=>e.preventDefault(), {passive:false}));

// --- Canvas & board (square letterbox center)
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
let W=0,H=0,DPR=1; // css px
let board = { x:0, y:0, size:0 };

function setupCanvas(){
  DPR = Math.max(1, Math.min(2, window.devicePixelRatio||1));
  const w = Math.floor(window.innerWidth);
  const h = Math.floor(window.innerHeight);
  canvas.width = Math.floor(w*DPR);
  canvas.height = Math.floor(h*DPR);
  canvas.style.width = w+'px'; canvas.style.height = h+'px';
  ctx.setTransform(DPR,0,0,DPR,0,0);
  W = w; H = h;
  // board square sized to min dimension, centered
  const s = Math.floor(Math.min(W, H) * 0.92); // leave margin
  board.size = s; board.x = Math.floor((W - s)/2); board.y = Math.floor((H - s)/2);
}
function boardToScreen(p){ return { x: board.x + p.x*board.size, y: board.y + p.y*board.size }; }
function screenToBoard(px,py){ return { x: (px - board.x)/board.size, y: (py - board.y)/board.size }; }

// --- Levels (relative 0..1 coords in board space) 20 patterns
const levels = [
  [{x:.2,y:.2},{x:.8,y:.2},{x:.8,y:.8},{x:.2,y:.8}],
  [{x:.2,y:.3},{x:.5,y:.2},{x:.8,y:.3},{x:.8,y:.7},{x:.5,y:.8},{x:.2,y:.7}],
  [{x:.2,y:.8},{x:.8,y:.8},{x:.5,y:.2}],
  [{x:.2,y:.2},{x:.8,y:.8},{x:.8,y:.2},{x:.2,y:.8},{x:.5,y:.5}],
  [{x:.5,y:.2},{x:.5,y:.8},{x:.2,y:.5},{x:.8,y:.5},{x:.5,y:.5}],
  [{x:.2,y:.3},{x:.35,y:.6},{x:.5,y:.3},{x:.65,y:.6},{x:.8,y:.3}],
  [{x:.5,y:.2},{x:.8,y:.5},{x:.5,y:.8},{x:.2,y:.5}],
  [{x:.5,y:.18},{x:.78,y:.38},{x:.67,y:.78},{x:.33,y:.78},{x:.22,y:.38}],
  [{x:.3,y:.25},{x:.7,y:.25},{x:.85,y:.55},{x:.7,y:.85},{x:.3,y:.85},{x:.15,y:.55}],
  [{x:.5,y:.15},{x:.6,y:.45},{x:.9,y:.45},{x:.65,y:.62},{x:.75,y:.9},{x:.5,y:.72},{x:.25,y:.9},{x:.35,y:.62},{x:.1,y:.45},{x:.4,y:.45}],
  [{x:.2,y:.2},{x:.8,y:.2},{x:.8,y:.8},{x:.3,y:.8},{x:.3,y:.3},{x:.7,y:.3},{x:.7,y:.7},{x:.4,y:.7},{x:.4,y:.4}],
  [{x:.2,y:.3},{x:.35,y:.2},{x:.5,y:.35},{x:.65,y:.5},{x:.5,y:.65},{x:.35,y:.8},{x:.2,y:.7},{x:.8,y:.7}],
  [{x:.25,y:.25},{x:.4,y:.35},{x:.7,y:.3},{x:.6,y:.6},{x:.35,y:.7},{x:.15,y:.55},{x:.85,y:.75}],
  [{x:.25,y:.25},{x:.45,y:.25},{x:.45,y:.4},{x:.6,y:.4},{x:.6,y:.55},{x:.75,y:.55}],
  [{x:.25,y:.7},{x:.75,y:.7},{x:.75,y:.45},{x:.5,y:.25},{x:.25,y:.45}],
  [{x:.25,y:.5},{x:.5,y:.35},{x:.75,y:.5},{x:.6,y:.6},{x:.4,y:.6}],
  [{x:.3,y:.35},{x:.4,y:.25},{x:.5,y:.35},{x:.6,y:.25},{x:.7,y:.35},{x:.5,y:.75}],
  [{x:.5,y:.15},{x:.7,y:.22},{x:.82,y:.4},{x:.7,y:.68},{x:.5,y:.75},{x:.3,y:.68},{x:.18,y:.4},{x:.3,y:.22}],
  [{x:.2,y:.35},{x:.35,y:.5},{x:.5,y:.35},{x:.65,y:.5},{x:.8,y:.35}],
  [{x:.25,y:.25},{x:.5,y:.25},{x:.75,y:.25},{x:.25,y:.5},{x:.5,y:.5},{x:.75,y:.5},{x:.25,y:.75},{x:.5,y:.75},{x:.75,y:.75}]
];

// --- State
let currentLevel = 0;
let visited = new Set(); // indices of nodes visited
let path = []; // array of points in board coords {x,y}
let activePointerId = null;
let drawing = false;

const NODE_R = 0.04; // radius in board units
const PATH_MIN_DIST = 0.006; // minimal distance in board units to push path

// --- Utilities
function nodes(){ return levels[currentLevel]; }
function updateHud(){ document.getElementById('hud').textContent = `Level ${currentLevel+1} / ${levels.length}`; }

// --- Drawing
function draw(){
  ctx.clearRect(0,0,W,H);
  // background panel
  ctx.fillStyle = '#071021'; ctx.fillRect(0,0,W,H);

  // board area background
  ctx.fillStyle = '#041220'; ctx.fillRect(board.x, board.y, board.size, board.size);

  // subtle grid
  ctx.save(); ctx.beginPath(); ctx.rect(board.x, board.y, board.size, board.size); ctx.clip();
  ctx.globalAlpha = 0.1; ctx.strokeStyle = '#123449';
  for(let gx = board.x; gx <= board.x+board.size; gx += 40) { ctx.beginPath(); ctx.moveTo(gx, board.y); ctx.lineTo(gx, board.y+board.size); ctx.stroke(); }
  for(let gy = board.y; gy <= board.y+board.size; gy += 40) { ctx.beginPath(); ctx.moveTo(board.x, gy); ctx.lineTo(board.x+board.size, gy); ctx.stroke(); }
  ctx.restore();

  // draw path
  if (path.length > 0){
    ctx.lineJoin='round'; ctx.lineCap='round'; ctx.lineWidth = Math.max(6, board.size*0.02); ctx.strokeStyle = '#22c55e';
    ctx.beginPath();
    const p0 = boardToScreen(path[0]); ctx.moveTo(p0.x, p0.y);
    for(let i=1;i<path.length;i++){ const ps = boardToScreen(path[i]); ctx.lineTo(ps.x, ps.y); }
    ctx.stroke();
  }

  // draw nodes
  nodes().forEach((n, idx) =>{
    const s = boardToScreen(n);
    ctx.beginPath(); ctx.arc(s.x, s.y, NODE_R*board.size, 0, Math.PI*2);
    ctx.fillStyle = visited.has(idx)? '#22c55e' : '#0ea5e9';
    ctx.shadowColor = visited.has(idx)? '#22c55e' : '#0ea5e9'; ctx.shadowBlur = visited.has(idx)? 0 : 8; ctx.fill(); ctx.shadowBlur = 0;
  });
}

// --- Input handling (pointer)
canvas.addEventListener('pointerdown', (e)=>{
  const rect = canvas.getBoundingClientRect(); const x = e.clientX - rect.left, y = e.clientY - rect.top;
  if (activePointerId !== null) return; // already handling another pointer
  const b = screenToBoard(x,y);
  const hit = nodeIndexAt(b.x, b.y);
  if (hit !== -1){
    activePointerId = e.pointerId; canvas.setPointerCapture(activePointerId);
    drawing = true; visited = new Set([hit]); path = [{x: nodes()[hit].x, y: nodes()[hit].y}]; updateHud(); draw();
  }
});
canvas.addEventListener('pointermove', (e)=>{
  if (!drawing || e.pointerId !== activePointerId) return; const rect = canvas.getBoundingClientRect(); const x = e.clientX - rect.left, y = e.clientY - rect.top;
  const b = screenToBoard(x,y);
  // add intermediate path points if moved enough
  const last = path[path.length-1]; if (Math.hypot(b.x-last.x, b.y-last.y) > PATH_MIN_DIST) path.push({x:b.x,y:b.y});
  const hit = nodeIndexAt(b.x, b.y);
  if (hit !== -1 && !visited.has(hit)){
    visited.add(hit); // snap to center
    path.push({x: nodes()[hit].x, y: nodes()[hit].y});
    if (visited.size === nodes().length){ onWin(); }
  }
  draw();
});
canvas.addEventListener('pointerup', (e)=>{ if (e.pointerId !== activePointerId) return; endStroke(); });
canvas.addEventListener('pointercancel', (e)=>{ if (e.pointerId !== activePointerId) return; endStroke(); });

function endStroke(){ drawing = false; if (activePointerId!==null){ try{ canvas.releasePointerCapture(activePointerId); }catch{} } activePointerId=null; if (visited.size < nodes().length){ showToast('Belum semua titik tersambung'); visited = new Set(); path = []; draw(); } }

function nodeIndexAt(bx,by){
  for(let i=0;i<nodes().length;i++){ const p=nodes()[i]; if (Math.hypot(bx-p.x, by-p.y) <= NODE_R) return i; } return -1;
}

// --- Win / level flow
const overlay = document.getElementById('overlay'); const overlayTitle = document.getElementById('overlayTitle'); const overlayDesc = document.getElementById('overlayDesc'); const nextBtn = document.getElementById('nextBtn'); const restartBtn = document.getElementById('restartBtn');
function onWin(){ drawing=false; const last = currentLevel === levels.length-1; overlayTitle.textContent = last? 'Semua Level Selesai!' : `Level ${currentLevel+1} Selesai!`; overlayDesc.textContent = last? 'Keren — kamu menuntaskan semua pola.' : `Siap ke Level ${currentLevel+2}?`; nextBtn.style.display = last? 'none':'inline-block'; restartBtn.style.display = last? 'inline-block':'none'; overlay.style.display='flex'; }
nextBtn.addEventListener('click', ()=>{ overlay.style.display='none'; loadLevel(currentLevel+1); }); restartBtn.addEventListener('click', ()=>{ overlay.style.display='none'; loadLevel(0); });

// --- Toast
const toastEl = document.getElementById('toast'); let toastTimer=null; function showToast(msg){ toastEl.textContent = msg; toastEl.classList.add('show'); clearTimeout(toastTimer); toastTimer = setTimeout(()=>toastEl.classList.remove('show'), 1200); }

// --- Resize & orientation handlers (keep state)
function redrawAfterLayout(){ setupCanvas(); draw(); }
window.addEventListener('resize', ()=>{ setTimeout(redrawAfterLayout, 160); });
window.addEventListener('orientationchange', async ()=>{ try{ if (screen.orientation?.type?.startsWith('portrait')) await screen.orientation.lock('landscape'); }catch{} setTimeout(redrawAfterLayout, 260); });

// --- Prevent back navigation
history.replaceState({game:true}, ''); window.addEventListener('popstate', e=>{ if (e.state && e.state.game) { history.pushState({game:true}, ''); draw(); } });

// --- Load level (only data reset) ---
function loadLevel(i){ currentLevel = (i + levels.length) % levels.length; visited = new Set(); path = []; updateHud(); draw(); }

// --- Start: fullscreen + lock landscape + init canvas
async function startGameFlow(){ const instr = document.getElementById('instructions'); const elem = document.documentElement; try{ await (elem.requestFullscreen?.call(elem) || elem.webkitRequestFullscreen?.call(elem)); }catch{} try{ await screen.orientation?.lock('landscape'); }catch{} instr.style.display = 'none'; setupCanvas(); updateHud(); loadLevel(0); }

document.getElementById('startBtn').addEventListener('click', startGameFlow);

// initial layout
setupCanvas(); updateHud(); draw();
</script></body>
</html>
