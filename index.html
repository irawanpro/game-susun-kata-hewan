<!doctype html>

<html lang="id">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <meta name="theme-color" content="#0f172a" />
  <link rel="manifest" href="/manifest.webmanifest" />
  <title>One Line Draw â€“ PWA</title>
  <style>
    html, body { height: 100%; margin: 0; background:#0f172a; color:#e2e8f0; }
    canvas { display:block; width:100%; height:100%; touch-action:none; }
    #startBtn { position: fixed; top: 10px; left: 10px; z-index: 10; padding: 10px 16px; border: none; background: #22c55e; color: #041016; border-radius: 8px; font-weight: bold; }
  </style>
</head>
<body>
  <button id="startBtn">Mulai Game</button>
  <canvas id="game"></canvas><script>
// Anti zoom
window.addEventListener('wheel', (e) => { if (e.ctrlKey) e.preventDefault(); }, { passive:false });
['gesturestart','gesturechange','gestureend'].forEach(ev => window.addEventListener(ev, e=>e.preventDefault(), {passive:false}));

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
let width, height;
function resizeCanvas() {
  width = canvas.clientWidth;
  height = canvas.clientHeight;
  canvas.width = width;
  canvas.height = height;
  draw();
}
window.addEventListener('resize', resizeCanvas);

// Level data: titik dan urutan sambungan
const nodes = [
  {x:0.2, y:0.2},
  {x:0.8, y:0.2},
  {x:0.8, y:0.8},
  {x:0.2, y:0.8}
];
let visited = [];
let drawing = false;
let currentPath = [];

function draw(){
  ctx.clearRect(0,0,width,height);
  ctx.lineJoin = 'round';
  ctx.lineCap = 'round';

  // Garis sambungan permanen
  if (currentPath.length > 0) {
    ctx.strokeStyle = '#22c55e';
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.moveTo(currentPath[0].x, currentPath[0].y);
    for (let i=1;i<currentPath.length;i++) {
      ctx.lineTo(currentPath[i].x, currentPath[i].y);
    }
    ctx.stroke();
  }

  // Titik
  nodes.forEach((n,i)=>{
    ctx.beginPath();
    ctx.arc(n.x*width, n.y*height, 12, 0, Math.PI*2);
    ctx.fillStyle = visited.includes(i) ? '#22c55e' : '#0ea5e9';
    ctx.fill();
  });
}

function getNodeAt(x,y){
  for (let i=0;i<nodes.length;i++){
    let dx = x - nodes[i].x*width;
    let dy = y - nodes[i].y*height;
    if (Math.sqrt(dx*dx+dy*dy) < 20) return i;
  }
  return null;
}

canvas.addEventListener('pointerdown', e=>{
  const rect = canvas.getBoundingClientRect();
  const node = getNodeAt(e.clientX - rect.left, e.clientY - rect.top);
  if (node !== null) {
    drawing = true;
    visited = [node];
    currentPath = [{x: nodes[node].x*width, y: nodes[node].y*height}];
    draw();
  }
});

canvas.addEventListener('pointermove', e=>{
  if (!drawing) return;
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  currentPath.push({x, y});
  const node = getNodeAt(x, y);
  if (node !== null && !visited.includes(node)) {
    visited.push(node);
    if (visited.length === nodes.length) {
      setTimeout(()=>alert('Berhasil! Semua titik terhubung'), 100);
    }
  }
  draw();
});

window.addEventListener('pointerup', ()=>{ drawing = false; });

// Fullscreen + orientasi landscape lock & auto-correct
async function enterFullscreen() {
  const elem = document.documentElement;
  if (elem.requestFullscreen) await elem.requestFullscreen();
  else if (elem.webkitRequestFullscreen) await elem.webkitRequestFullscreen();

  if (screen.orientation && screen.orientation.lock) {
    try { await screen.orientation.lock('landscape'); } catch (e) {}
  }
}

window.addEventListener('orientationchange', async () => {
  if (screen.orientation.type.startsWith('portrait')) {
    try { await screen.orientation.lock('landscape'); } catch (e) {}
  }
});

document.getElementById('startBtn').addEventListener('click', ()=>{
  enterFullscreen();
});

resizeCanvas();
</script></body>
</html>
